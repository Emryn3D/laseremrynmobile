<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>EMRYN Measurement Tool</title>
<style>
  :root{
    --bg: rgba(14, 15, 18, 0.95);
    --panel: rgba(21, 24, 33, 0.9);
    --muted: rgba(39, 43, 54, 0.8);
    --text: #e8ecf1;
    --sub: #b6c0cf;
    --accent: #69b3ff;
    --danger: #ff6b6b;
    --ok: #52d273;
    --overlay: rgba(0, 0, 0, 0.5);
    --emryn-red: #ff2953;
  }
  
  * { box-sizing: border-box; }
  html, body { 
    height: 100%; 
    margin: 0; 
    padding: 0;
    overflow: hidden;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
  }
  
  body {
    background: #0e0f12;
    color: var(--text);
    position: relative;
  }

  /* Top toolbar like DISTO */
  .top-toolbar {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    height: 60px;
    background: var(--emryn-red);
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 15px;
    z-index: 100;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
  }

  .toolbar-left {
    display: flex;
    align-items: center;
    gap: 15px;
  }

  .emryn-logo {
    height: 32px;
    width: auto;
    cursor: pointer;
    filter: invert(1);
  }

  .back-btn {
    color: #fff;
    font-size: 24px;
    cursor: pointer;
    padding: 8px;
    border-radius: 4px;
    transition: background-color 0.2s;
  }

  .back-btn:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  .toolbar-center {
    flex: 1;
    text-align: center;
  }

  .project-info {
    color: #fff;
    font-size: 14px;
    font-weight: 500;
  }

  .toolbar-right {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .toolbar-btn {
    background: none;
    border: none;
    color: #fff;
    font-size: 12px;
    padding: 8px 12px;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 2px;
    min-width: 50px;
  }

  .toolbar-btn:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  .toolbar-btn-icon {
    font-size: 18px;
  }

  /* Dropdown menus */
  .dropdown {
    position: relative;
  }

  .dropdown-menu {
    position: absolute;
    top: 100%;
    right: 0;
    min-width: 180px;
    background: var(--panel);
    backdrop-filter: blur(20px);
    border: 1px solid var(--muted);
    border-radius: 8px;
    padding: 8px 0;
    z-index: 200;
    opacity: 0;
    visibility: hidden;
    transform: translateY(-10px);
    transition: all 0.2s ease;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
  }

  .dropdown.open .dropdown-menu {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
  }

  .dropdown-item {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 16px;
    color: var(--text);
    cursor: pointer;
    transition: background-color 0.2s;
    border: none;
    background: none;
    width: 100%;
    text-align: left;
  }

  .dropdown-item:hover {
    background: rgba(105, 179, 255, 0.1);
  }

  .dropdown-item-icon {
    width: 20px;
    text-align: center;
  }

  /* Main canvas area */
  .main {
    position: fixed;
    top: 60px;
    left: 0;
    right: 0;
    bottom: 70px;
    background: #0a0b0e;
  }

  #canvasContainer {
    position: relative;
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    touch-action: none;
  }

  #imageCanvas, #drawCanvas {
    position: absolute;
    max-width: 100%;
    max-height: 100%;
  }
  
  #imageCanvas {
    background: #0b0e13;
    z-index: 1;
  }
  
  #drawCanvas {
    background: transparent;
    z-index: 2;
    touch-action: none;
  }

  /* Side panel (narrower like DISTO) */
  .side-panel {
    position: fixed;
    top: 60px;
    right: 0;
    width: 280px;
    height: calc(100vh - 130px);
    background: var(--panel);
    backdrop-filter: blur(20px);
    border-left: 1px solid var(--muted);
    transform: translateX(100%);
    transition: transform 0.3s ease;
    z-index: 150;
    overflow-y: auto;
    padding: 20px;
  }

  .side-panel.open {
    transform: translateX(0);
  }

  .panel-overlay {
    position: fixed;
    top: 60px;
    left: 0;
    right: 280px;
    bottom: 70px;
    background: var(--overlay);
    backdrop-filter: blur(2px);
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s ease;
    z-index: 140;
  }

  .panel-overlay.visible {
    opacity: 1;
    pointer-events: auto;
  }

  /* Menu sections */
  .menu-section {
    margin-bottom: 24px;
    padding-bottom: 16px;
    border-bottom: 1px solid var(--muted);
  }

  .menu-section:last-child {
    border-bottom: none;
  }

  .menu-section h3 {
    margin: 0 0 12px 0;
    font-size: 13px;
    font-weight: 600;
    color: var(--accent);
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }

  .menu-row {
    display: flex;
    gap: 8px;
    margin-bottom: 10px;
    align-items: center;
    flex-wrap: wrap;
  }

  .menu-row:last-child {
    margin-bottom: 0;
  }

  /* Bottom toolbar */
  .bottom-toolbar {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    height: 70px;
    background: var(--panel);
    backdrop-filter: blur(20px);
    border-top: 1px solid var(--muted);
    display: flex;
    align-items: center;
    justify-content: space-around;
    padding: 0 20px;
    z-index: 90;
  }

  .bottom-btn {
    background: var(--muted);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    color: var(--text);
    padding: 10px 16px;
    cursor: pointer;
    font-size: 13px;
    transition: all 0.2s ease;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    min-width: 60px;
    min-height: 50px;
  }

  .bottom-btn:hover, .bottom-btn.active {
    background: var(--accent);
    color: #000;
    transform: translateY(-2px);
  }

  .bottom-btn.danger {
    background: var(--danger);
    color: #fff;
  }

  .bottom-btn-icon {
    font-size: 18px;
  }

  /* Floating controls */
  .floating-controls {
    position: fixed;
    bottom: 90px;
    right: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    z-index: 80;
  }

  .float-btn {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background: var(--panel);
    backdrop-filter: blur(10px);
    border: 1px solid var(--muted);
    color: var(--text);
    font-size: 16px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
    transition: all 0.2s ease;
  }

  .float-btn:hover {
    background: var(--accent);
    color: #000;
    transform: scale(1.05);
  }

  .float-btn.laser-active {
    background: var(--ok);
    color: #000;
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }

  /* Laser control */
  .laser-control {
    position: fixed;
    bottom: 90px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 80;
  }

  .laser-btn {
    width: 80px;
    height: 80px;
    border-radius: 50%;
    background: #333;
    border: 4px solid #555;
    color: #fff;
    font-size: 12px;
    font-weight: bold;
    cursor: pointer;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
    transition: all 0.2s ease;
  }

  .laser-btn.connected {
    background: var(--ok);
    border-color: #4a9960;
    color: #000;
  }

  .laser-btn.measuring {
    background: var(--emryn-red);
    border-color: #ff1a47;
    animation: pulse 1s infinite;
  }

  /* Buttons and inputs */
  .btn {
    padding: 10px 14px;
    border: 1px solid var(--muted);
    border-radius: 6px;
    background: var(--muted);
    color: var(--text);
    cursor: pointer;
    font-size: 13px;
    transition: all 0.2s ease;
    text-align: center;
    min-height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .btn:hover, .btn:active {
    background: var(--accent);
    color: #000;
    transform: translateY(-1px);
  }

  .btn.active {
    background: var(--accent);
    color: #000;
    border-color: var(--accent);
  }

  .btn.danger {
    background: var(--danger);
    border-color: var(--danger);
    color: #fff;
  }

  .btn.ok {
    background: var(--ok);
    border-color: var(--ok);
    color: #000;
  }

  .btn-group {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px;
    width: 100%;
  }

  .btn-group.three {
    grid-template-columns: 1fr 1fr 1fr;
  }

  .btn-full {
    width: 100%;
  }

  /* Inputs */
  .input {
    padding: 10px;
    border: 1px solid var(--muted);
    border-radius: 6px;
    background: rgba(0, 0, 0, 0.3);
    color: var(--text);
    font-size: 13px;
    width: 100%;
    min-height: 40px;
  }

  .input:focus {
    outline: none;
    border-color: var(--accent);
    box-shadow: 0 0 0 2px rgba(105, 179, 255, 0.2);
  }

  .input-group {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px;
  }

  .input-group.four {
    grid-template-columns: 1fr 1fr 1fr 60px;
  }

  /* Color palette */
  .color-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 6px;
  }

  .color-swatch {
    width: 100%;
    height: 34px;
    border: 2px solid transparent;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .color-swatch.selected {
    border-color: var(--accent);
    transform: scale(1.05);
    box-shadow: 0 0 0 2px rgba(105, 179, 255, 0.3);
  }

  /* Range slider */
  .slider {
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: var(--muted);
    outline: none;
    -webkit-appearance: none;
  }

  .slider::-webkit-slider-thumb {
    appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
  }

  /* Radio groups */
  .radio-group {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px;
  }

  .radio-option {
    position: relative;
    cursor: pointer;
  }

  .radio-option input[type="radio"] {
    position: absolute;
    opacity: 0;
    pointer-events: none;
  }

  .radio-option .radio-label {
    display: block;
    padding: 10px;
    border: 1px solid var(--muted);
    border-radius: 6px;
    background: var(--muted);
    color: var(--text);
    text-align: center;
    transition: all 0.2s ease;
    min-height: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .radio-option input:checked + .radio-label {
    background: var(--accent);
    color: #000;
    border-color: var(--accent);
  }

  /* Chips */
  .chips {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-top: 8px;
  }

  .chip {
    background: rgba(27, 31, 42, 0.8);
    border: 1px solid var(--muted);
    padding: 6px 10px;
    border-radius: 16px;
    cursor: pointer;
    font-size: 11px;
    transition: all 0.2s ease;
  }

  .chip:hover {
    background: var(--accent);
    color: #000;
  }

  /* Quick measurement input */
  .quick-measure-popup {
    position: fixed;
    bottom: 160px;
    right: 75px;
    width: 200px;
    background: var(--panel);
    backdrop-filter: blur(20px);
    border: 1px solid var(--muted);
    border-radius: 8px;
    padding: 15px;
    z-index: 200;
    opacity: 0;
    visibility: hidden;
    transform: translateY(10px) scale(0.95);
    transition: all 0.2s ease;
    box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
  }

  .quick-measure-popup.visible {
    opacity: 1;
    visibility: visible;
    transform: translateY(0) scale(1);
  }

  .quick-measure-popup::after {
    content: '';
    position: absolute;
    bottom: -8px;
    right: 20px;
    width: 0;
    height: 0;
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    border-top: 8px solid var(--panel);
  }

  /* Modal */
  .modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: var(--overlay);
    backdrop-filter: blur(5px);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 999;
    padding: 20px;
  }

  .modal.hidden {
    display: none;
  }

  .modal-content {
    background: var(--panel);
    backdrop-filter: blur(20px);
    border: 1px solid var(--muted);
    border-radius: 12px;
    padding: 24px;
    width: 100%;
    max-width: 400px;
    max-height: 80vh;
    overflow-y: auto;
  }

  .modal h3 {
    margin: 0 0 16px 0;
    font-size: 16px;
    color: var(--accent);
  }

  .modal label {
    display: block;
    margin: 0 0 4px 0;
    font-size: 12px;
    color: var(--sub);
    font-weight: 500;
  }

  .hint {
    color: var(--sub);
    font-size: 10px;
    margin-top: 6px;
    line-height: 1.3;
  }

  .hidden { display: none !important; }

  /* Responsive */
  @media (max-width: 480px) {
    .side-panel {
      width: 100vw;
      padding: 15px;
    }
    
    .panel-overlay {
      right: 0;
    }
    
    .toolbar-right {
      gap: 8px;
    }
    
    .toolbar-btn {
      min-width: 40px;
      font-size: 10px;
    }
    
    .quick-measure-popup {
      right: 15px;
      width: 180px;
    }
  }
</style>
</head>
<body>
  <!-- Top toolbar like DISTO -->
  <div class="top-toolbar">
    <div class="toolbar-left">
      <!-- EMRYN logo (will be replaced with your logo) -->
      <svg class="emryn-logo" viewBox="0 0 200 50" xmlns="http://www.w3.org/2000/svg">
        <text x="10" y="35" font-family="Arial, sans-serif" font-size="32" font-weight="bold" fill="white">EMRYN</text>
      </svg>
      <div class="back-btn" id="backBtn">‚Üê</div>
    </div>
    
    <div class="toolbar-center">
      <div class="project-info" id="projectInfo">New Project</div>
    </div>
    
    <div class="toolbar-right">
      <div class="dropdown" id="exportDropdown">
        <button class="toolbar-btn" id="exportBtn">
          <div class="toolbar-btn-icon">‚Üó</div>
          <div>Export</div>
        </button>
        <div class="dropdown-menu">
          <button class="dropdown-item" id="exportJpgBtn">
            <div class="dropdown-item-icon">üñº</div>
            <span>JPG</span>
          </button>
          <button class="dropdown-item" id="exportPdfBtn">
            <div class="dropdown-item-icon">üìÑ</div>
            <span>PDF Basic</span>
          </button>
          <button class="dropdown-item" id="exportProBtn">
            <div class="dropdown-item-icon">üìã</div>
            <span>PDF Pro</span>
          </button>
        </div>
      </div>
      
      <div class="dropdown" id="toolsDropdown">
        <button class="toolbar-btn" id="toolsBtn">
          <div class="toolbar-btn-icon">üõ†</div>
          <div>Tools</div>
        </button>
        <div class="dropdown-menu">
          <button class="dropdown-item" id="drawSettingsBtn">
            <div class="dropdown-item-icon">‚öô</div>
            <span>Draw Settings</span>
          </button>
          <button class="dropdown-item" id="textToolBtn">
            <div class="dropdown-item-icon">T</div>
            <span>Text</span>
          </button>
          <button class="dropdown-item" id="markerToolBtn">
            <div class="dropdown-item-icon">üìç</div>
            <span>Marker</span>
          </button>
          <button class="dropdown-item" id="editTagsBtn">
            <div class="dropdown-item-icon">üè∑</div>
            <span>Edit Tags</span>
          </button>
        </div>
      </div>
      
      <button class="toolbar-btn" id="undoToolbarBtn">
        <div class="toolbar-btn-icon">‚Ü∂</div>
        <div>Undo</div>
      </button>
      
      <button class="toolbar-btn" id="newBtn">
        <div class="toolbar-btn-icon">üìÑ</div>
        <div>New</div>
      </button>
    </div>
  </div>

  <!-- Main canvas area -->
  <main class="main">
    <div id="canvasContainer">
      <canvas id="imageCanvas"></canvas>
      <canvas id="drawCanvas"></canvas>
    </div>
  </main>

  <!-- Side panel overlay -->
  <div class="panel-overlay" id="panelOverlay"></div>

  <!-- Side panel -->
  <div class="side-panel" id="sidePanel">
    <!-- File Operations -->
    <div class="menu-section">
      <h3>File</h3>
      <input id="fileInput" type="file" accept="image/*" class="hidden" />
      <div class="btn-group">
        <button class="btn" id="chooseBtn">Gallery</button>
        <button class="btn" id="cameraBtn">Camera</button>
      </div>
      <div class="menu-row" style="margin-top: 10px;">
        <input class="input" id="projectInput" type="text" placeholder="Project Name" />
      </div>
      <div class="menu-row">
        <input class="input" id="areaInput" type="text" placeholder="Area/Room" />
      </div>
    </div>

    <!-- Colors -->
    <div class="menu-section">
      <h3>Colors</h3>
      <div class="color-grid" id="colorGrid"></div>
    </div>

    <!-- Line Style -->
    <div class="menu-section">
      <h3>Line Style</h3>
      <div class="menu-row">
        <label>Width: <span id="widthDisplay">3</span></label>
      </div>
      <div class="menu-row">
        <input class="slider" id="widthSlider" type="range" min="1" max="12" value="3" />
      </div>
      <div class="radio-group" style="margin-top: 12px;">
        <div class="radio-option">
          <input type="radio" name="endcap" value="arrow" id="capArrow" checked />
          <label class="radio-label" for="capArrow">Arrows</label>
        </div>
        <div class="radio-option">
          <input type="radio" name="endcap" value="circle" id="capCircle" />
          <label class="radio-label" for="capCircle">Circles</label>
        </div>
      </div>
    </div>

    <!-- Measurements -->
    <div class="menu-section">
      <h3>Measurements</h3>
      <div class="radio-group">
        <div class="radio-option">
          <input type="radio" name="units" value="imperial" id="unitsImperial" checked />
          <label class="radio-label" for="unitsImperial">Imperial</label>
        </div>
        <div class="radio-option">
          <input type="radio" name="units" value="metric" id="unitsMetric" />
          <label class="radio-label" for="unitsMetric">Metric</label>
        </div>
      </div>

      <!-- Imperial inputs -->
      <div id="imperialInputs">
        <div class="input-group four" style="margin-top: 12px;">
          <input class="input" id="ftInput" type="number" placeholder="ft" />
          <input class="input" id="inInput" type="number" placeholder="in" />
          <input class="input" id="numInput" type="number" placeholder="num" />
          <select class="input" id="fracSelect">
            <option value="2">/2</option>
            <option value="4">/4</option>
            <option value="8" selected>/8</option>
            <option value="16">/16</option>
            <option value="32">/32</option>
          </select>
        </div>
        <button class="btn ok btn-full" id="applyImperialBtn" style="margin-top: 8px;">Apply</button>
      </div>

      <!-- Metric inputs -->
      <div id="metricInputs" class="hidden">
        <div class="menu-row" style="margin-top: 12px;">
          <input class="input" id="mmInput" type="number" placeholder="mm" style="flex: 1;" />
          <button class="btn ok" id="applyMetricBtn">Apply</button>
        </div>
      </div>

      <!-- Inbox -->
      <div style="margin-top: 16px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
          <span style="font-size: 11px; color: var(--sub);">Inbox</span>
          <button class="btn" id="clearInboxBtn" style="padding: 2px 6px; font-size: 10px;">Clear</button>
        </div>
        <div class="chips" id="inbox"></div>
        <div class="hint">Tap measurement to apply to selected line</div>
      </div>
    </div>

    <!-- Bluetooth -->
    <div class="menu-section">
      <h3>Bluetooth Laser</h3>
      <div class="menu-row">
        <select class="input" id="deviceSelect">
          <option value="auto">Auto-detect</option>
          <option value="leica">Leica DISTO</option>
          <option value="bosch">Bosch GLM</option>
        </select>
      </div>
      <div class="btn-group">
        <button class="btn" id="connectBtn">Connect</button>
        <button class="btn" id="disconnectBtn" disabled>Disconnect</button>
      </div>
      <div class="menu-row" style="margin-top: 8px;">
        <label style="display: flex; align-items: center; gap: 6px;">
          <input type="checkbox" id="beepToggle" checked />
          <span>Beep on measurement</span>
        </label>
      </div>
      <button class="btn btn-full" id="testBtn">Test: 8' 6"</button>
      <div class="hint">Requires HTTPS. Measurements auto-apply to selected lines.</div>
    </div>

    <!-- Settings -->
    <div class="menu-section">
      <h3>Settings</h3>
      <button class="btn btn-full" id="settingsBtn">Company Info</button>
    </div>
  </div>

  <!-- Bottom toolbar -->
  <div class="bottom-toolbar">
    <button class="bottom-btn active" id="drawToolBtn">
      <div class="bottom-btn-icon">‚úèÔ∏è</div>
      <div>Draw</div>
    </button>
    <button class="bottom-btn" id="selectToolBtn">
      <div class="bottom-btn-icon">üëÜ</div>
      <div>Select</div>
    </button>
    <button class="bottom-btn danger" id="deleteToolBtn">
      <div class="bottom-btn-icon">üóë</div>
      <div>Delete</div>
    </button>
  </div>

  <!-- Floating controls -->
  <div class="floating-controls">
    <button class="float-btn" id="undoFloatBtn" title="Undo">
      <div>‚Ü∂</div>
    </button>
    <button class="float-btn" id="measureFloatBtn" title="Quick Measure">
      <div>üìè</div>
    </button>
  </div>

  <!-- Laser control (like DISTO) -->
  <div class="laser-control">
    <button class="laser-btn" id="laserBtn">
      <div style="font-size: 10px;">LASER</div>
      <div id="laserStatus">OFF</div>
    </button>
  </div>

  <!-- Quick measurement popup -->
  <div class="quick-measure-popup" id="quickMeasurePopup">
    <h4 style="margin: 0 0 10px 0; font-size: 12px; color: var(--accent);">Quick Measure</h4>
    <div id="quickImperialInputs">
      <div class="input-group four">
        <input class="input" id="quickFtInput" type="number" placeholder="ft" style="font-size: 12px; padding: 6px;" />
        <input class="input" id="quickInInput" type="number" placeholder="in" style="font-size: 12px; padding: 6px;" />
        <input class="input" id="quickNumInput" type="number" placeholder="num" style="font-size: 12px; padding: 6px;" />
        <select class="input" id="quickFracSelect" style="font-size: 12px; padding: 6px;">
          <option value="8" selected>/8</option>
          <option value="16">/16</option>
        </select>
      </div>
      <button class="btn ok btn-full" id="quickApplyBtn" style="margin-top: 8px; padding: 6px;">Apply</button>
    </div>
    <div id="quickMetricInputs" class="hidden">
      <div style="display: flex; gap: 6px;">
        <input class="input" id="quickMmInput" type="number" placeholder="mm" style="flex: 1; font-size: 12px; padding: 6px;" />
        <button class="btn ok" id="quickApplyMetricBtn" style="padding: 6px 10px;">Apply</button>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div id="settingsModal" class="modal hidden">
    <div class="modal-content">
      <h3>Company Settings</h3>
      
      <label>Company Name</label>
      <input class="input" id="companyNameInput" type="text" placeholder="EMRYN" />
      
      <label>Email</label>
      <input class="input" id="companyEmailInput" type="text" placeholder="contact@emryn.com" />
      
      <label>Address</label>
      <input class="input" id="companyAddressInput" type="text" placeholder="Company Address" />
      
      <label>Logo</label>
      <input class="input" id="logoInput" type="file" accept="image/*" />
      
      <div class="btn-group" style="margin-top: 16px;">
        <button class="btn ok" id="saveSettingsBtn">Save</button>
        <button class="btn" id="cancelSettingsBtn">Cancel</button>
      </div>
      
      <div class="hint">Settings saved locally on your device</div>
    </div>
  </div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
(() => {
  // State
  const state = {
    tool: 'draw',
    colors: ['#ff4d4f','#ffa502','#ffd166','#2ed573','#1e90ff','#a29bfe','#f368e0','#f1f2f6','#57606a'],
    activeColor: '#1e90ff',
    lineWidth: 3,
    endCap: 'arrow',
    units: 'imperial',
    tagPrefix: 'A',
    tagCounter: 1,
    shapes: [],
    selectedShape: null,
    dragging: null,
    image: null,
    imageNaturalSize: {w: 0, h: 0},
    canvasScale: 1,
    zoom: 1,
    history: [],
    bluetooth: {device: null, connected: false, measuring: false},
    settings: {company: 'EMRYN', email: '', address: '', logo: null},
    panelOpen: false,
    quickMeasureOpen: false
  };

  // Elements
  const imageCanvas = document.getElementById('imageCanvas');
  const drawCanvas = document.getElementById('drawCanvas');
  const container = document.getElementById('canvasContainer');
  const imgCtx = imageCanvas.getContext('2d');
  const drawCtx = drawCanvas.getContext('2d');
  
  const sidePanel = document.getElementById('sidePanel');
  const panelOverlay = document.getElementById('panelOverlay');
  const quickMeasurePopup = document.getElementById('quickMeasurePopup');
  const laserBtn = document.getElementById('laserBtn');
  const laserStatus = document.getElementById('laserStatus');

  // Initialize
  loadSettings();
  setupColorPalette();
  setupEventListeners();
  drawPlaceholder();
  updateProjectInfo();

  function setupColorPalette() {
    const grid = document.getElementById('colorGrid');
    grid.innerHTML = '';
    
    state.colors.forEach(color => {
      const swatch = document.createElement('div');
      swatch.className = 'color-swatch';
      swatch.style.backgroundColor = color;
      if (color === state.activeColor) {
        swatch.classList.add('selected');
      }
      
      swatch.addEventListener('click', () => {
        document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
        swatch.classList.add('selected');
        state.activeColor = color;
        
        // Apply to selected shape
        const selected = getSelectedShape();
        if (selected) {
          saveToHistory();
          selected.color = color;
          redraw();
        }
      });
      
      grid.appendChild(swatch);
    });
  }

  function setupEventListeners() {
    // Dropdown toggles
    document.getElementById('exportBtn').addEventListener('click', (e) => {
      e.stopPropagation();
      toggleDropdown('exportDropdown');
    });
    
    document.getElementById('toolsBtn').addEventListener('click', (e) => {
      e.stopPropagation();
      toggleDropdown('toolsDropdown');
    });

    // Close dropdowns when clicking outside
    document.addEventListener('click', () => {
      closeAllDropdowns();
    });

    // Back button and panel toggle
    document.getElementById('backBtn').addEventListener('click', () => {
      if (state.panelOpen) {
        togglePanel(false);
      } else {
        // Could add navigation logic here
      }
    });

    // Draw settings opens panel
    document.getElementById('drawSettingsBtn').addEventListener('click', () => {
      closeAllDropdowns();
      togglePanel(true);
    });

    // Panel overlay
    panelOverlay.addEventListener('click', () => togglePanel(false));

    // File operations
    document.getElementById('chooseBtn').addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });
    
    document.getElementById('fileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (file) loadImageFile(file);
    });

    document.getElementById('cameraBtn').addEventListener('click', openCamera);

    // Project inputs
    document.getElementById('projectInput').addEventListener('input', updateProjectInfo);
    document.getElementById('areaInput').addEventListener('input', updateProjectInfo);

    // Tools
    document.getElementById('drawToolBtn').addEventListener('click', () => setTool('draw'));
    document.getElementById('selectToolBtn').addEventListener('click', () => setTool('select'));
    document.getElementById('deleteToolBtn').addEventListener('click', deleteSelected);

    // Undo buttons
    document.getElementById('undoToolbarBtn').addEventListener('click', undo);
    document.getElementById('undoFloatBtn').addEventListener('click', undo);

    // Quick measure
    document.getElementById('measureFloatBtn').addEventListener('click', toggleQuickMeasure);
    document.getElementById('quickApplyBtn').addEventListener('click', applyQuickImperial);
    document.getElementById('quickApplyMetricBtn').addEventListener('click', applyQuickMetric);

    // Laser control
    laserBtn.addEventListener('click', toggleLaser);

    // Style controls
    document.getElementById('widthSlider').addEventListener('input', (e) => {
      const width = parseInt(e.target.value);
      state.lineWidth = width;
      document.getElementById('widthDisplay').textContent = width;
      
      const selected = getSelectedShape();
      if (selected) {
        selected.width = width;
        redraw();
      }
    });

    // End caps
    document.querySelectorAll('input[name="endcap"]').forEach(radio => {
      radio.addEventListener('change', () => {
        state.endCap = document.querySelector('input[name="endcap"]:checked').value;
        const selected = getSelectedShape();
        if (selected) {
          selected.cap = state.endCap;
          redraw();
        }
      });
    });

    // Units
    document.querySelectorAll('input[name="units"]').forEach(radio => {
      radio.addEventListener('change', () => {
        state.units = document.querySelector('input[name="units"]:checked').value;
        document.getElementById('imperialInputs').classList.toggle('hidden', state.units !== 'imperial');
        document.getElementById('metricInputs').classList.toggle('hidden', state.units !== 'metric');
        document.getElementById('quickImperialInputs').classList.toggle('hidden', state.units !== 'imperial');
        document.getElementById('quickMetricInputs').classList.toggle('hidden', state.units !== 'metric');
      });
    });

    // Measurement inputs
    document.getElementById('applyImperialBtn').addEventListener('click', applyImperialMeasurement);
    document.getElementById('applyMetricBtn').addEventListener('click', applyMetricMeasurement);
    document.getElementById('clearInboxBtn').addEventListener('click', () => {
      document.getElementById('inbox').innerHTML = '';
    });

    // Bluetooth
    document.getElementById('connectBtn').addEventListener('click', connectBluetooth);
    document.getElementById('disconnectBtn').addEventListener('click', disconnectBluetooth);
    document.getElementById('testBtn').addEventListener('click', () => {
      simulateBluetoothReading("8' 6\"");
    });

    // Export
    document.getElementById('exportJpgBtn').addEventListener('click', () => {
      closeAllDropdowns();
      exportJPG();
    });
    document.getElementById('exportPdfBtn').addEventListener('click', () => {
      closeAllDropdowns();
      exportPDF(false);
    });
    document.getElementById('exportProBtn').addEventListener('click', () => {
      closeAllDropdowns();
      exportPDF(true);
    });

    // Settings
    document.getElementById('settingsBtn').addEventListener('click', openSettings);
    document.getElementById('saveSettingsBtn').addEventListener('click', saveSettings);
    document.getElementById('cancelSettingsBtn').addEventListener('click', closeSettings);

    // Canvas interactions
    setupCanvasEvents();

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
        e.preventDefault();
        undo();
      }
      if (e.key === 'Delete') {
        deleteSelected();
      }
      if (e.key === 'Escape') {
        closeAllDropdowns();
        togglePanel(false);
        toggleQuickMeasure(false);
      }
    });

    // Drag and drop
    document.addEventListener('dragover', (e) => e.preventDefault());
    document.addEventListener('drop', (e) => {
      e.preventDefault();
      const file = e.dataTransfer.files[0];
      if (file && file.type.startsWith('image/')) {
        loadImageFile(file);
      }
    });
  }

  function toggleDropdown(dropdownId) {
    closeAllDropdowns();
    const dropdown = document.getElementById(dropdownId);
    dropdown.classList.add('open');
  }

  function closeAllDropdowns() {
    document.querySelectorAll('.dropdown').forEach(d => d.classList.remove('open'));
  }

  function togglePanel(force = null) {
    state.panelOpen = force !== null ? force : !state.panelOpen;
    sidePanel.classList.toggle('open', state.panelOpen);
    panelOverlay.classList.toggle('visible', state.panelOpen);
  }

  function toggleQuickMeasure(force = null) {
    state.quickMeasureOpen = force !== null ? force : !state.quickMeasureOpen;
    quickMeasurePopup.classList.toggle('visible', state.quickMeasureOpen);
  }

  function updateProjectInfo() {
    const project = document.getElementById('projectInput').value || 'New';
    const area = document.getElementById('areaInput').value || 'Project';
    document.getElementById('projectInfo').textContent = `${project} - ${area}`;
  }

  function setTool(tool) {
    state.tool = tool;
    
    // Update toolbar
    document.getElementById('drawToolBtn').classList.toggle('active', tool === 'draw');
    document.getElementById('selectToolBtn').classList.toggle('active', tool === 'select');
  }

  async function openCamera() {
    togglePanel(false);
    
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: 'environment' },
          width: { ideal: 1920 },
          height: { ideal: 1080 }
        }
      });

      const cameraContainer = document.createElement('div');
      Object.assign(cameraContainer.style, {
        position: 'fixed',
        top: '0',
        left: '0',
        width: '100vw',
        height: '100vh',
        background: '#000',
        zIndex: '1000',
        display: 'flex',
        flexDirection: 'column'
      });

      const video = document.createElement('video');
      video.srcObject = stream;
      video.autoplay = true;
      video.playsInline = true;
      Object.assign(video.style, {
        width: '100%',
        height: '100%',
        objectFit: 'cover'
      });

      const controls = document.createElement('div');
      Object.assign(controls.style, {
        position: 'absolute',
        bottom: '0',
        left: '0',
        right: '0',
        padding: '30px',
        background: 'linear-gradient(transparent, rgba(0,0,0,0.8))',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        gap: '30px'
      });

      const captureBtn = document.createElement('button');
      captureBtn.textContent = 'Capture';
      Object.assign(captureBtn.style, {
        width: '80px',
        height: '80px',
        borderRadius: '50%',
        background: 'var(--emryn-red)',
        color: '#fff',
        border: '4px solid #fff',
        fontSize: '12px',
        fontWeight: 'bold',
        cursor: 'pointer',
        boxShadow: '0 4px 20px rgba(0,0,0,0.5)'
      });

      const closeBtn = document.createElement('button');
      closeBtn.innerHTML = '‚úï';
      Object.assign(closeBtn.style, {
        position: 'absolute',
        top: '20px',
        right: '20px',
        width: '40px',
        height: '40px',
        borderRadius: '50%',
        background: 'rgba(0,0,0,0.6)',
        color: '#fff',
        border: 'none',
        fontSize: '20px',
        cursor: 'pointer'
      });

      controls.appendChild(captureBtn);
      cameraContainer.appendChild(video);
      cameraContainer.appendChild(controls);
      cameraContainer.appendChild(closeBtn);
      document.body.appendChild(cameraContainer);

      const cleanup = () => {
        stream.getTracks().forEach(track => track.stop());
        cameraContainer.remove();
      };

      captureBtn.addEventListener('click', () => {
        const canvas = document.createElement('canvas');
        canvas.width = video.videoWidth || 1920;
        canvas.height = video.videoHeight || 1080;
        
        const ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0);
        
        canvas.toBlob((blob) => {
          const file = new File([blob], 'camera-capture.jpg', { type: 'image/jpeg' });
          loadImageFile(file);
          cleanup();
        }, 'image/jpeg', 0.9);
      });

      closeBtn.addEventListener('click', cleanup);

    } catch (err) {
      console.error('Camera access failed:', err);
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = 'image/*';
      input.capture = 'environment';
      input.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) loadImageFile(file);
      });
      input.click();
    }
  }

  function loadImageFile(file) {
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        state.image = img;
        state.imageNaturalSize = { w: img.naturalWidth, h: img.naturalHeight };
        fitToScreen();
      };
      img.onerror = () => {
        alert('Failed to load image. Please try a different format.');
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  }

  function fitToScreen() {
    if (!state.image) {
      drawPlaceholder();
      return;
    }

    const main = document.querySelector('.main');
    const containerRect = main.getBoundingClientRect();
    const containerW = containerRect.width;
    const containerH = containerRect.height;
    const imgW = state.imageNaturalSize.w;
    const imgH = state.imageNaturalSize.h;

    const scale = Math.min(containerW / imgW, containerH / imgH, 1);
    
    const canvasW = Math.floor(imgW * scale);
    const canvasH = Math.floor(imgH * scale);

    imageCanvas.width = drawCanvas.width = canvasW;
    imageCanvas.height = drawCanvas.height = canvasH;
    
    state.canvasScale = scale;
    state.zoom = 1;
    container.style.transform = 'scale(1)';
    container.style.transformOrigin = '50% 50%';

    drawImage();
    redraw();
  }

  function drawImage() {
    imgCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
    if (state.image) {
      imgCtx.drawImage(state.image, 0, 0, imageCanvas.width, imageCanvas.height);
    } else {
      drawPlaceholder();
    }
  }

  function drawPlaceholder() {
    const w = imageCanvas.width || 400;
    const h = imageCanvas.height || 300;
    
    imgCtx.fillStyle = '#0b0e13';
    imgCtx.fillRect(0, 0, w, h);
    
    imgCtx.strokeStyle = '#161a22';
    imgCtx.lineWidth = 1;
    
    for (let x = 0; x < w; x += 40) {
      imgCtx.beginPath();
      imgCtx.moveTo(x, 0);
      imgCtx.lineTo(x, h);
      imgCtx.stroke();
    }
    
    for (let y = 0; y < h; y += 40) {
      imgCtx.beginPath();
      imgCtx.moveTo(0, y);
      imgCtx.lineTo(w, y);
      imgCtx.stroke();
    }

    imgCtx.fillStyle = '#666';
    imgCtx.font = '16px system-ui';
    imgCtx.textAlign = 'center';
    imgCtx.textBaseline = 'middle';
    imgCtx.fillText('Tap Camera or Gallery to load image', w/2, h/2);
  }

  function setupCanvasEvents() {
    let isDrawing = false;
    let startPoint = null;
    let lastTouch = 0;

    drawCanvas.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      const point = getCanvasPoint(e);
      const now = Date.now();

      if (now - lastTouch < 300) {
        fitToScreen();
        return;
      }
      lastTouch = now;

      if (state.tool === 'draw') {
        isDrawing = true;
        startPoint = point;
      } else if (state.tool === 'select') {
        handleSelection(point);
      }
    });

    drawCanvas.addEventListener('pointermove', (e) => {
      if (!isDrawing && !state.dragging) return;
      
      e.preventDefault();
      const point = getCanvasPoint(e);

      if (isDrawing && startPoint) {
        drawPreview(startPoint, point);
      } else if (state.dragging) {
        handleDrag(point);
      }
    });

    drawCanvas.addEventListener('pointerup', (e) => {
      if (isDrawing && startPoint) {
        const point = getCanvasPoint(e);
        addMeasurementLine(startPoint, point);
        isDrawing = false;
        startPoint = null;
      }
      state.dragging = null;
    });

    // Pinch zoom
    let initialDistance = 0;
    let initialZoom = 1;
    
    drawCanvas.addEventListener('touchstart', (e) => {
      if (e.touches.length === 2) {
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        initialDistance = Math.hypot(
          touch1.clientX - touch2.clientX,
          touch1.clientY - touch2.clientY
        );
        initialZoom = state.zoom;
      }
    });

    drawCanvas.addEventListener('touchmove', (e) => {
      if (e.touches.length === 2) {
        e.preventDefault();
        const touch1 = e.touches[0];
        const touch2 = e.touches[1];
        const currentDistance = Math.hypot(
          touch1.clientX - touch2.clientX,
          touch1.clientY - touch2.clientY
        );

        if (initialDistance > 0) {
          const scale = currentDistance / initialDistance;
          const newZoom = Math.max(0.5, Math.min(3, initialZoom * scale));
          adjustZoom(newZoom / state.zoom);
        }
      }
    });
  }

  function getCanvasPoint(e) {
    const rect = drawCanvas.getBoundingClientRect();
    const scaleX = drawCanvas.width / rect.width;
    const scaleY = drawCanvas.height / rect.height;
    
    return {
      x: (e.clientX - rect.left) * scaleX,
      y: (e.clientY - rect.top) * scaleY
    };
  }

  function drawPreview(start, end) {
    redraw();
    drawCtx.save();
    drawCtx.strokeStyle = state.activeColor;
    drawCtx.lineWidth = state.lineWidth;
    drawCtx.setLineDash([8, 4]);
    drawCtx.beginPath();
    drawCtx.moveTo(start.x, start.y);
    drawCtx.lineTo(end.x, end.y);
    drawCtx.stroke();
    drawCtx.restore();
  }

  function addMeasurementLine(p1, p2) {
    const distance = Math.hypot(p2.x - p1.x, p2.y - p1.y);
    if (distance < 10) return;

    saveToHistory();
    
    const shape = {
      id: generateId(),
      p1: { ...p1 },
      p2: { ...p2 },
      color: state.activeColor,
      width: state.lineWidth,
      cap: state.endCap,
      tag: generateTag(),
      measurement: null,
      units: state.units,
      description: ''
    };

    state.shapes.push(shape);
    state.selectedShape = shape.id;
    redraw();
  }

  function handleSelection(point) {
    let hitShape = null;
    let hitType = null;
    
    for (const shape of [...state.shapes].reverse()) {
      if (distance(point, shape.p1) < 20) {
        hitShape = shape;
        hitType = 'p1';
        break;
      }
      if (distance(point, shape.p2) < 20) {
        hitShape = shape;
        hitType = 'p2';
        break;
      }
      
      const lineDistance = distanceToLine(point, shape.p1, shape.p2);
      if (lineDistance < Math.max(15, shape.width + 5)) {
        hitShape = shape;
        hitType = 'line';
        break;
      }
    }

    if (hitShape) {
      state.selectedShape = hitShape.id;
      if (hitType === 'p1' || hitType === 'p2' || hitType === 'line') {
        saveToHistory();
        state.dragging = hitType;
      }
    } else {
      state.selectedShape = null;
    }
    
    redraw();
  }

  function handleDrag(point) {
    const shape = getSelectedShape();
    if (!shape) return;

    if (state.dragging === 'p1') {
      shape.p1 = { ...point };
    } else if (state.dragging === 'p2') {
      shape.p2 = { ...point };
    } else if (state.dragging === 'line') {
      const center = {
        x: (shape.p1.x + shape.p2.x) / 2,
        y: (shape.p1.y + shape.p2.y) / 2
      };
      const dx = point.x - center.x;
      const dy = point.y - center.y;
      
      shape.p1.x += dx;
      shape.p1.y += dy;
      shape.p2.x += dx;
      shape.p2.y += dy;
    }
    
    redraw();
  }

  function redraw() {
    drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
    
    for (const shape of state.shapes) {
      drawMeasurementLine(shape);
    }
  }

  function drawMeasurementLine(shape) {
    const isSelected = shape.id === state.selectedShape;
    
    drawCtx.save();
    drawCtx.strokeStyle = shape.color;
    drawCtx.lineWidth = shape.width;
    drawCtx.lineCap = 'round';
    drawCtx.beginPath();
    drawCtx.moveTo(shape.p1.x, shape.p1.y);
    drawCtx.lineTo(shape.p2.x, shape.p2.y);
    drawCtx.stroke();
    
    drawEndCap(shape.p1, shape.p2, shape.color, shape.width, shape.cap);
    drawEndCap(shape.p2, shape.p1, shape.color, shape.width, shape.cap);
    
    drawTag(shape);
    
    if (shape.measurement) {
      drawMeasurementLabel(shape);
    }
    
    if (isSelected) {
      drawSelectionHandles(shape);
    }
    
    drawCtx.restore();
  }

  function drawEndCap(point, otherPoint, color, width, capType) {
    const angle = Math.atan2(point.y - otherPoint.y, point.x - otherPoint.x);
    
    drawCtx.save();
    drawCtx.translate(point.x, point.y);
    drawCtx.rotate(angle);
    drawCtx.fillStyle = color;
    
    if (capType === 'arrow') {
      drawCtx.beginPath();
      drawCtx.moveTo(0, 0);
      drawCtx.lineTo(-12, -6);
      drawCtx.lineTo(-12, 6);
      drawCtx.closePath();
      drawCtx.fill();
    } else if (capType === 'circle') {
      drawCtx.beginPath();
      drawCtx.arc(0, 0, width * 1.5 + 3, 0, Math.PI * 2);
      drawCtx.fill();
    }
    
    drawCtx.restore();
  }

  function drawTag(shape) {
    const center = {
      x: (shape.p1.x + shape.p2.x) / 2,
      y: (shape.p1.y + shape.p2.y) / 2
    };
    
    const dx = shape.p2.x - shape.p1.x;
    const dy = shape.p2.y - shape.p1.y;
    const len = Math.hypot(dx, dy) || 1;
    const nx = -dy / len;
    const ny = dx / len;
    
    const tagPos = {
      x: center.x + nx * 20,
      y: center.y + ny * 20
    };
    
    drawBadge(shape.tag, tagPos, shape.color);
  }

  function drawMeasurementLabel(shape) {
    const center = {
      x: (shape.p1.x + shape.p2.x) / 2,
      y: (shape.p1.y + shape.p2.y) / 2
    };
    
    const labelPos = {
      x: center.x + 50,
      y: center.y - 20
    };
    
    drawCtx.save();
    drawCtx.strokeStyle = shape.color;
    drawCtx.lineWidth = 1;
    drawCtx.setLineDash([4, 4]);
    drawCtx.beginPath();
    drawCtx.moveTo(center.x, center.y);
    drawCtx.lineTo(labelPos.x, labelPos.y);
    drawCtx.stroke();
    drawCtx.restore();
    
    drawBubble(formatMeasurement(shape.measurement, shape.units), labelPos);
  }

  function drawBadge(text, pos, color) {
    drawCtx.save();
    drawCtx.font = '11px system-ui';
    drawCtx.textAlign = 'center';
    drawCtx.textBaseline = 'middle';
    
    const metrics = drawCtx.measureText(text);
    const w = metrics.width + 12;
    const h = 20;
    
    drawCtx.fillStyle = color;
    drawCtx.beginPath();
    drawCtx.roundRect(pos.x - w/2, pos.y - h/2, w, h, 10);
    drawCtx.fill();
    
    const luminance = getLuminance(color);
    drawCtx.fillStyle = luminance > 0.5 ? '#000' : '#fff';
    drawCtx.fillText(text, pos.x, pos.y);
    
    drawCtx.restore();
  }

  function drawBubble(text, pos) {
    if (!text) return;
    
    drawCtx.save();
    drawCtx.font = '12px system-ui';
    drawCtx.textAlign = 'center';
    drawCtx.textBaseline = 'middle';
    
    const metrics = drawCtx.measureText(text);
    const w = metrics.width + 16;
    const h = 24;
    
    drawCtx.fillStyle = 'rgba(18, 20, 27, 0.9)';
    drawCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    drawCtx.lineWidth = 1;
    drawCtx.beginPath();
    drawCtx.roundRect(pos.x - w/2, pos.y - h/2, w, h, 12);
    drawCtx.fill();
    drawCtx.stroke();
    
    drawCtx.fillStyle = '#fff';
    drawCtx.fillText(text, pos.x, pos.y);
    
    drawCtx.restore();
  }

  function drawSelectionHandles(shape) {
    const points = [shape.p1, shape.p2];
    
    drawCtx.save();
    drawCtx.fillStyle = '#fff';
    drawCtx.strokeStyle = '#000';
    drawCtx.lineWidth = 2;
    
    for (const point of points) {
      drawCtx.beginPath();
      drawCtx.arc(point.x, point.y, 8, 0, Math.PI * 2);
      drawCtx.fill();
      drawCtx.stroke();
    }
    
    drawCtx.restore();
  }

  // Laser control functions
  function toggleLaser() {
    if (!state.bluetooth.connected) {
      connectBluetooth();
      return;
    }

    if (state.bluetooth.measuring) {
      stopMeasurement();
    } else {
      startMeasurement();
    }
  }

  function startMeasurement() {
    state.bluetooth.measuring = true;
    laserBtn.classList.add('measuring');
    laserStatus.textContent = 'MEASURING...';
    
    // Simulate laser measurement or trigger actual Bluetooth command
    setTimeout(() => {
      // This would normally come from Bluetooth
      simulateBluetoothReading("12' 4-3/8\"");
      stopMeasurement();
    }, 2000);
  }

  function stopMeasurement() {
    state.bluetooth.measuring = false;
    laserBtn.classList.remove('measuring');
    laserStatus.textContent = state.bluetooth.connected ? 'READY' : 'OFF';
  }

  // Bluetooth functionality
  async function connectBluetooth() {
    if (!navigator.bluetooth) {
      alert('Bluetooth not supported. Requires HTTPS.');
      return;
    }

    try {
      const device = await navigator.bluetooth.requestDevice({
        acceptAllDevices: true,
        optionalServices: ['generic_access']
      });

      const server = await device.gatt.connect();
      state.bluetooth.device = device;
      state.bluetooth.connected = true;
      
      laserBtn.classList.add('connected');
      laserStatus.textContent = 'READY';
      
      document.getElementById('connectBtn').disabled = true;
      document.getElementById('disconnectBtn').disabled = false;
      
      device.addEventListener('gattserverdisconnected', () => {
        state.bluetooth.connected = false;
        laserBtn.classList.remove('connected', 'measuring');
        laserStatus.textContent = 'OFF';
        document.getElementById('connectBtn').disabled = false;
        document.getElementById('disconnectBtn').disabled = true;
      });

      const services = await server.getPrimaryServices();
      for (const service of services) {
        try {
          const characteristics = await service.getCharacteristics();
          for (const char of characteristics) {
            if (char.properties.notify) {
              await char.startNotifications();
              char.addEventListener('characteristicvaluechanged', handleBluetoothData);
            }
          }
        } catch (err) {
          console.warn('Service access failed:', err);
        }
      }
      
    } catch (err) {
      console.error('Bluetooth failed:', err);
      alert('Bluetooth connection failed: ' + err.message);
    }
  }

  function disconnectBluetooth() {
    if (state.bluetooth.device) {
      state.bluetooth.device.gatt.disconnect();
    }
  }

  function handleBluetoothData(event) {
    const value = event.target.value;
    let measurement = null;
    
    try {
      const text = new TextDecoder().decode(value);
      measurement = parseMeasurementText(text);
    } catch (err) {
      if (value.byteLength >= 2) {
        const mm = value.getUint16(0, true);
        measurement = { value: mm, units: 'metric' };
      }
    }
    
    if (measurement) {
      if (document.getElementById('beepToggle').checked) {
        playBeep();
      }
      applyMeasurement(measurement);
      stopMeasurement();
    }
  }

  function simulateBluetoothReading(text) {
    const measurement = parseMeasurementText(text);
    if (measurement) {
      if (document.getElementById('beepToggle').checked) {
        playBeep();
      }
      applyMeasurement(measurement);
    }
  }

  function parseMeasurementText(text) {
    text = text.trim().toLowerCase();
    
    const imperial = text.match(/(\d+)[\'\s]*(\d+(?:\.\d+)?)\s*(?:-\s*(\d+)\/(\d+))?/);
    if (imperial) {
      const ft = parseInt(imperial[1]) || 0;
      const inches = parseFloat(imperial[2]) || 0;
      const num = parseInt(imperial[3]) || 0;
      const den = parseInt(imperial[4]) || 1;
      const totalInches = ft * 12 + inches + num / den;
      return { value: totalInches, units: 'imperial' };
    }
    
    const mm = text.match(/([\d.]+)\s*mm/);
    if (mm) {
      return { value: parseFloat(mm[1]), units: 'metric' };
    }
    
    const cm = text.match(/([\d.]+)\s*cm/);
    if (cm) {
      return { value: parseFloat(cm[1]) * 10, units: 'metric' };
    }
    
    const m = text.match(/([\d.]+)\s*m(?!m)/);
    if (m) {
      return { value: parseFloat(m[1]) * 1000, units: 'metric' };
    }
    
    return null;
  }

  function applyMeasurement(measurement) {
    const selected = getSelectedShape();
    
    if (selected) {
      selected.measurement = measurement.value;
      selected.units = measurement.units;
      redraw();
    } else {
      addToInbox(measurement);
    }
  }

  function addToInbox(measurement) {
    const inbox = document.getElementById('inbox');
    const chip = document.createElement('div');
    chip.className = 'chip';
    chip.textContent = formatMeasurement(measurement.value, measurement.units);
    chip.dataset.value = measurement.value;
    chip.dataset.units = measurement.units;
    
    chip.addEventListener('click', () => {
      const selected = getSelectedShape();
      if (selected) {
        selected.measurement = parseFloat(chip.dataset.value);
        selected.units = chip.dataset.units;
        chip.remove();
        redraw();
      }
    });
    
    inbox.appendChild(chip);
  }

  function applyQuickImperial() {
    const ft = parseFloat(document.getElementById('quickFtInput').value || '0');
    const inches = parseFloat(document.getElementById('quickInInput').value || '0');
    const num = parseFloat(document.getElementById('quickNumInput').value || '0');
    const den = parseFloat(document.getElementById('quickFracSelect').value || '1');
    
    const totalInches = ft * 12 + inches + num / den;
    applyMeasurement({ value: totalInches, units: 'imperial' });
    
    document.getElementById('quickFtInput').value = '';
    document.getElementById('quickInInput').value = '';
    document.getElementById('quickNumInput').value = '';
    toggleQuickMeasure(false);
  }

  function applyQuickMetric() {
    const mm = parseFloat(document.getElementById('quickMmInput').value || '0');
    applyMeasurement({ value: mm, units: 'metric' });
    
    document.getElementById('quickMmInput').value = '';
    toggleQuickMeasure(false);
  }

  function applyImperialMeasurement() {
    const ft = parseFloat(document.getElementById('ftInput').value || '0');
    const inches = parseFloat(document.getElementById('inInput').value || '0');
    const num = parseFloat(document.getElementById('numInput').value || '0');
    const den = parseFloat(document.getElementById('fracSelect').value || '1');
    
    const totalInches = ft * 12 + inches + num / den;
    applyMeasurement({ value: totalInches, units: 'imperial' });
    
    document.getElementById('ftInput').value = '';
    document.getElementById('inInput').value = '';
    document.getElementById('numInput').value = '';
  }

  function applyMetricMeasurement() {
    const mm = parseFloat(document.getElementById('mmInput').value || '0');
    applyMeasurement({ value: mm, units: 'metric' });
    
    document.getElementById('mmInput').value = '';
  }

  function formatMeasurement(value, units) {
    if (units === 'imperial') {
      const sign = value < 0 ? '-' : '';
      value = Math.abs(value);
      const feet = Math.floor(value / 12);
      const remainingInches = value - feet * 12;
      const wholeInches = Math.floor(remainingInches);
      const fraction = remainingInches - wholeInches;
      
      const denom = 16;
      let num = Math.round(fraction * denom);
      
      if (num === denom) {
        return `${sign}${feet}' ${wholeInches + 1}"`;
      } else if (num === 0) {
        return `${sign}${feet}' ${wholeInches}"`;
      } else {
        return `${sign}${feet}' ${wholeInches}-${num}/${denom}"`;
      }
    } else {
      return `${Math.round(value)} mm`;
    }
  }

  function adjustZoom(factor) {
    state.zoom = Math.max(0.5, Math.min(3, state.zoom * factor));
    container.style.transform = `scale(${state.zoom})`;
  }

  function deleteSelected() {
    if (!state.selectedShape) return;
    
    saveToHistory();
    state.shapes = state.shapes.filter(s => s.id !== state.selectedShape);
    state.selectedShape = null;
    redraw();
  }

  function undo() {
    if (state.history.length === 0) return;
    
    const previousState = state.history.pop();
    state.shapes = JSON.parse(JSON.stringify(previousState));
    state.selectedShape = null;
    redraw();
  }

  function saveToHistory() {
    if (state.history.length >= 20) {
      state.history.shift();
    }
    state.history.push(JSON.parse(JSON.stringify(state.shapes)));
  }

  // Utility functions
  function distance(p1, p2) {
    return Math.hypot(p2.x - p1.x, p2.y - p1.y);
  }

  function distanceToLine(point, lineStart, lineEnd) {
    const A = point.x - lineStart.x;
    const B = point.y - lineStart.y;
    const C = lineEnd.x - lineStart.x;
    const D = lineEnd.y - lineStart.y;

    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    
    if (lenSq === 0) return distance(point, lineStart);
    
    let param = dot / lenSq;
    
    let xx, yy;
    if (param < 0) {
      xx = lineStart.x;
      yy = lineStart.y;
    } else if (param > 1) {
      xx = lineEnd.x;
      yy = lineEnd.y;
    } else {
      xx = lineStart.x + param * C;
      yy = lineStart.y + param * D;
    }

    return distance(point, {x: xx, y: yy});
  }

  function getSelectedShape() {
    return state.shapes.find(s => s.id === state.selectedShape);
  }

  function generateId() {
    return Date.now().toString(36) + Math.random().toString(36);
  }

  function generateTag() {
    return state.tagPrefix + state.tagCounter++;
  }

  function getLuminance(hex) {
    const rgb = parseInt(hex.slice(1), 16);
    const r = (rgb >> 16) & 255;
    const g = (rgb >> 8) & 255;
    const b = rgb & 255;
    return (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  }

  function playBeep() {
    try {
      const audioContext = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      
      oscillator.frequency.value = 800;
      gainNode.gain.value = 0.1;
      
      oscillator.start();
      setTimeout(() => {
        oscillator.stop();
        audioContext.close();
      }, 150);
    } catch (err) {
      console.warn('Audio not supported');
    }
  }

  // Export functions
  function exportJPG() {
    if (!state.image) {
      alert('Please load an image first');
      return;
    }

    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = imageCanvas.width;
    exportCanvas.height = imageCanvas.height;
    
    const ctx = exportCanvas.getContext('2d');
    ctx.drawImage(state.image, 0, 0, exportCanvas.width, exportCanvas.height);
    
    for (const shape of state.shapes) {
      drawShapeToCanvas(ctx, shape, 1);
    }
    
    exportCanvas.toBlob(blob => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = getFileName('jpg');
      a.click();
      URL.revokeObjectURL(url);
    }, 'image/jpeg', 0.9);
  }

  function exportPDF(detailed = false) {
    if (!state.image) {
      alert('Please load an image first');
      return;
    }

    const { jsPDF } = window.jspdf;
    const doc = new jsPDF();
    
    doc.setFontSize(16);
    doc.text('EMRYN Measurement Report', 20, 30);
    
    const project = document.getElementById('projectInput').value || 'Project';
    const area = document.getElementById('areaInput').value || 'Area';
    
    doc.setFontSize(12);
    doc.text(`${project} - ${area}`, 20, 50);
    doc.text(`Created: ${new Date().toLocaleDateString()}`, 20, 65);
    
    const exportCanvas = document.createElement('canvas');
    exportCanvas.width = imageCanvas.width;
    exportCanvas.height = imageCanvas.height;
    
    const ctx = exportCanvas.getContext('2d');
    ctx.drawImage(state.image, 0, 0, exportCanvas.width, exportCanvas.height);
    
    for (const shape of state.shapes) {
      drawShapeToCanvas(ctx, shape, 1);
    }
    
    const imgData = exportCanvas.toDataURL('image/jpeg', 0.8);
    doc.addImage(imgData, 'JPEG', 20, 80, 170, 170 * (exportCanvas.height / exportCanvas.width));
    
    if (detailed && state.shapes.length > 0) {
      doc.addPage();
      doc.setFontSize(14);
      doc.text('Measurements', 20, 30);
      
      let y = 50;
      doc.setFontSize(10);
      
      state.shapes.forEach((shape, i) => {
        const measurement = shape.measurement ? 
          formatMeasurement(shape.measurement, shape.units) : 'No measurement';
        
        doc.text(`${shape.tag}: ${measurement}`, 20, y);
        if (shape.description) {
          doc.text(shape.description, 60, y);
        }
        y += 15;
        
        if (y > 270) {
          doc.addPage();
          y = 30;
        }
      });
    }
    
    doc.save(getFileName('pdf'));
  }

  function drawShapeToCanvas(ctx, shape, scale = 1) {
    ctx.save();
    
    const p1 = { x: shape.p1.x * scale, y: shape.p1.y * scale };
    const p2 = { x: shape.p2.x * scale, y: shape.p2.y * scale };
    
    ctx.strokeStyle = shape.color;
    ctx.lineWidth = shape.width * scale;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(p1.x, p1.y);
    ctx.lineTo(p2.x, p2.y);
    ctx.stroke();
    
    const angle1 = Math.atan2(p1.y - p2.y, p1.x - p2.x);
    const angle2 = Math.atan2(p2.y - p1.y, p2.x - p1.x);
    
    [p1, p2].forEach((point, i) => {
      const angle = i === 0 ? angle1 : angle2;
      ctx.save();
      ctx.translate(point.x, point.y);
      ctx.rotate(angle);
      ctx.fillStyle = shape.color;
      
      if (shape.cap === 'arrow') {
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-12 * scale, -6 * scale);
        ctx.lineTo(-12 * scale, 6 * scale);
        ctx.closePath();
        ctx.fill();
      } else {
        ctx.beginPath();
        ctx.arc(0, 0, (shape.width * 1.5 + 3) * scale, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    });
    
    const center = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
    const dx = p2.x - p1.x;
    const dy = p2.y - p1.y;
    const len = Math.hypot(dx, dy) || 1;
    const tagPos = {
      x: center.x - (dy / len) * 20 * scale,
      y: center.y + (dx / len) * 20 * scale
    };
    
    ctx.font = `${11 * scale}px system-ui`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    
    const metrics = ctx.measureText(shape.tag);
    const w = (metrics.width + 12) * scale;
    const h = 20 * scale;
    
    ctx.fillStyle = shape.color;
    ctx.beginPath();
    ctx.roundRect(tagPos.x - w/2, tagPos.y - h/2, w, h, 10 * scale);
    ctx.fill();
    
    ctx.fillStyle = getLuminance(shape.color) > 0.5 ? '#000' : '#fff';
    ctx.fillText(shape.tag, tagPos.x, tagPos.y);
    
    if (shape.measurement) {
      const labelText = formatMeasurement(shape.measurement, shape.units);
      const labelPos = { x: center.x + 50 * scale, y: center.y - 20 * scale };
      
      ctx.strokeStyle = shape.color;
      ctx.lineWidth = 1 * scale;
      ctx.setLineDash([4 * scale, 4 * scale]);
      ctx.beginPath();
      ctx.moveTo(center.x, center.y);
      ctx.lineTo(labelPos.x, labelPos.y);
      ctx.stroke();
      ctx.setLineDash([]);
      
      ctx.font = `${12 * scale}px system-ui`;
      const labelMetrics = ctx.measureText(labelText);
      const labelW = (labelMetrics.width + 16) * scale;
      const labelH = 24 * scale;
      
      ctx.fillStyle = 'rgba(18, 20, 27, 0.9)';
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.lineWidth = 1 * scale;
      ctx.beginPath();
      ctx.roundRect(labelPos.x - labelW/2, labelPos.y - labelH/2, labelW, labelH, 12 * scale);
      ctx.fill();
      ctx.stroke();
      
      ctx.fillStyle = '#fff';
      ctx.fillText(labelText, labelPos.x, labelPos.y);
    }
    
    ctx.restore();
  }

  function getFileName(ext) {
    const project = document.getElementById('projectInput').value || 'Project';
    const area = document.getElementById('areaInput').value || 'Area';
    const timestamp = new Date().toISOString().slice(0, 10);
    return `${project}_${area}_${timestamp}.${ext}`;
  }

  // Settings
  function loadSettings() {
    try {
      const saved = localStorage.getItem('emrynMeasurementSettings');
      if (saved) {
        state.settings = { ...state.settings, ...JSON.parse(saved) };
      }
    } catch (err) {
      console.warn('Failed to load settings');
    }
  }

  function saveSettings() {
    const settings = {
      company: document.getElementById('companyNameInput').value.trim(),
      email: document.getElementById('companyEmailInput').value.trim(),
      address: document.getElementById('companyAddressInput').value.trim()
    };

    const logoFile = document.getElementById('logoInput').files[0];
    if (logoFile) {
      const reader = new FileReader();
      reader.onload = () => {
        settings.logo = reader.result;
        state.settings = settings;
        localStorage.setItem('emrynMeasurementSettings', JSON.stringify(settings));
        updateLogo();
        closeSettings();
      };
      reader.readAsDataURL(logoFile);
    } else {
      state.settings = settings;
      localStorage.setItem('emrynMeasurementSettings', JSON.stringify(settings));
      closeSettings();
    }
  }

  function updateLogo() {
    if (state.settings.logo) {
      const logoImg = document.querySelector('.emryn-logo');
      if (logoImg.tagName === 'SVG') {
        // Replace SVG with actual logo
        const img = document.createElement('img');
        img.src = state.settings.logo;
        img.className = 'emryn-logo';
        img.style.height = '32px';
        img.style.width = 'auto';
        img.style.cursor = 'pointer';
        logoImg.parentNode.replaceChild(img, logoImg);
      } else {
        logoImg.src = state.settings.logo;
      }
    }
  }

  function openSettings() {
    document.getElementById('companyNameInput').value = state.settings.company || '';
    document.getElementById('companyEmailInput').value = state.settings.email || '';
    document.getElementById('companyAddressInput').value = state.settings.address || '';
    document.getElementById('settingsModal').classList.remove('hidden');
    togglePanel(false);
  }

  function closeSettings() {
    document.getElementById('settingsModal').classList.add('hidden');
  }

  window.addEventListener('resize', () => {
    setTimeout(fitToScreen, 100);
  });

  function initCanvas() {
    const main = document.querySelector('.main');
    const rect = main.getBoundingClientRect();
    imageCanvas.width = drawCanvas.width = rect.width;
    imageCanvas.height = drawCanvas.height = rect.height;
    drawPlaceholder();
  }

  // Initialize logo if available
  updateLogo();
  initCanvas();
})();
</script>
</body>
</html>